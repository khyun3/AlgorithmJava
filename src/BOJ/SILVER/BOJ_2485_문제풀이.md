# 📝 알고리즘 문제 풀이

## 🔹 문제 정보

* 문제 번호: [2485 분수 합](https://www.acmicpc.net/problem/2485)
* 문제 유형: 수학,정수론,유클리드 호제법
* 난이도: 실버4
* 제약 조건: 1초 | 128MB

## 🔹 문제 정리

### 문제

* KOI 시에서는 가로수들이 모두 같은 간격이 되도록 가로수를 추가로 심는 사업을 추진하고 있다.
* KOI 시에서는 예산문제로 가능한 한 가장 적은 수의 나무를 심고 싶다.
* 편의상 가로수의 위치는 기준점으로 부터 떨어져 있는 거리로 표현되며, 가로수의 위치는 모두 양의 정수이다.
* 심어져 있는 가로수의 위치가 주어질 때, 모든 가로수가 같은 간격이 되도록 새로 심어야 하는 가로수의 최소수를 구하는 프로그램을 작성하라.

### 입력

> 첫째 줄에는 이미 심어져 있는 가로수의 수를 나타내는 하나의 정수 N이 주어진다(3 ≤ N ≤ 100,000).
> 둘째 줄부터 N개의 줄에는 각 줄마다 심어져 있는 가로수의 위치가 양의 정수로 주어지며, 가로수의 위치를 나타내는 정수는 1,000,000,000 이하이다.
> 가로수의 위치를 나타내는 정수는 모두 다르고, N개의 가로수는 기준점으로부터 떨어진 거리가 가까운 순서대로 주어진다.

### 출력

> 모든 가로수가 같은 간격이 되도록 새로 심어야 하는 가로수의 최소수를 첫 번째 줄에 출력한다.

## 🔹 풀이 순서

1. 가로수 수(N)를 입력 받는다.
2. 최초 최대공약수를 구하기 위해 1,2번은 loop전에 미리 받아서 사이간격(gap)을 구해둔다. 
3. 3번째부터 loop를 돌리고 입력값을 받아서 직전 구해두었던 간격과 와 다시 최대공약수를 구한다. 
4. l - a1로 범위를 구하고 gap으로 나눈 후 첫 나무 1개를 더해주면 전체 나무 개수가 나온다. 
5. 전체 나무 개수에서 기존 나무 N개를 뺀면 정답이다.

## 🔹 코드 구현

```java
public class BOJ_2485_가로수 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //1
        int N = Integer.parseInt(br.readLine());
        int[] trees = new int[N];

        //2
        trees[0] = Integer.parseInt(br.readLine());
        trees[1] = Integer.parseInt(br.readLine());
        int gap = trees[1] - trees[0];
        //3
        for (int i = 2; i < N; i++) {
            trees[i] = Integer.parseInt(br.readLine());
            gap = findGCD(gap, trees[i] - trees[i - 1]);
        }
        //4,5
        System.out.println(((trees[N - 1] - trees[0]) / gap) + 1 - N);
    }

    private static int findGCD(int a, int b) {
        while (b != 0) {
            int tmp = b;
            b = a % b;
            a = tmp;
        }
        return a;
    }
}

```

## 🔹 필요한 개념 정리

### 1️⃣ 수학 개념
* 기약분수
* 정의
    * '더 이상 약분되지 않는 분수'

* 유클리드 호제법
* 정의:
    * `두 정수의 최대공약수(GCD)`를 구하는 알고리즘.
    * 이 방법은 두 수를 나누는 과정을 반복하여 최대 공약수를 찾는 원리
    * 두 수 a와 b가 주어졌을 때, a를 b로 나눈 나머지를 r 이라고 함.
    * a와 b의 최대공약수는 b와 r의 최대공약수와 같음.
    * r이 0이 될 때까지 이 과정을 반복.
    * 이때의 b가 a와 b의 최대공약수입니다.

* 예:
    * 48과 18의 최대공약수를 구하는 과정은 다음과 같음.
    * 48을 18로 나눈 나머지는 12 (48 % 18 = 12)
    * 18을 12로 나눈 나머지는 6  (18 % 12 = 6)
    * 12를 6으로 나눈 나머지는 0  (12 % 6 = 0)
    * 나머지가 0이 되었으므로, 이때의 (b)인 6이 48과 18의 최대공약수

* 해당 문제에서 활용 방법:
* 두 분수의 합을 구하고 분모 분자를 gcd로 나눈다.