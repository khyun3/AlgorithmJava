# 📝 알고리즘 문제 풀이
## 🔹 문제 정보
  * 문제 번호: [창문 닫기](https://www.acmicpc.net/problem/13909)
  * 문제 유형: 수학, 정수론
  * 난이도: 실버5
  * 제약 조건: 1초 | 64MB

## 🔹 문제 정리
### 문제
  * 현재 N개의 창문이 있고 또 N명의 사람이 있다. 
  * 1번째 사람은 1의 배수 번째 창문을 열려 있으면 닫고 닫혀 있으면 연다.  
  * 2번째 사람은 2의 배수 번째 창문을 열려 있으면 닫고 닫혀 있으면 연다. 
  * 이러한 행동을 N번째 사람까지 진행한 후 열려 있는 창문의 개수를 구하라. 
  * 단, 처음에 모든 창문은 닫혀 있다.

### 입력
  > 첫 번째 줄에는 창문의 개수와 사람의 수 N(1 ≤ N ≤ 2,100,000,000)이 주어진다.
### 출력
  > 마지막에 열려 있는 창문의 개수를 출력한다.

## 아이디어
1. 브루트포스를 끝까지 돌린다. -> 시간 초과 날 것이 분명하다. 
2. N = 100까지만 돌려보자.
3. 무언가 규칙이 나올 것이다.
```java
public class BOJ_13909_창문닫기 {
  public static void main(String[] args) {

    for (int n = 1; n <= 100; n++) {
      boolean[] isOpenWindow = new boolean[n + 1];
      StringBuilder sb = new StringBuilder();
      for (int i = 1; i <= n; i++) {
        for (int j = i; j <= n; j += i) {
          isOpenWindow[j] = !isOpenWindow[j];
        }
      }
      sb.append(n).append(" : ");
      for (int j = 1; j <= n; j++) {
        sb.append(isOpenWindow[j] ? 1 : 0);
      }
      sb.append("\n");
      System.out.print(sb);
    }
  }
}
```
4. 규칙 : n^2일 때 + 1씩 증가한다.
```text
1 : 1                   -> 1
2 : 10                  -> 1
3 : 100                 -> 1
4 : 1001                -> 2
5 : 10010               -> 2
6 : 100100              -> 2
7 : 1001000             -> 2
8 : 10010000            -> 2
9 : 100100001           -> 3
10 : 1001000010         -> 3
11 : 10010000100        -> 3
12 : 100100001000       -> 3
13 : 1001000010000      -> 3
14 : 10010000100000     -> 3
15 : 100100001000000    -> 3
16 : 1001000010000001   -> 4
...
```

## 🔹 풀이 순서
1. N을 입력받는다.
2. N의 루트를 구한다.
3. 구한 N의 루트 출력한다.

## 🔹 코드 구현
```java
public class BOJ_13241_최소공배수 {
  public static void main(String[] args) throws IOException {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      
      String[] input = br.readLine().split(" ");
      long a = Integer.parseInt(input[0]);
      long b = Integer.parseInt(input[1]);

      System.out.println(findLCM(a, b));
  }
  static long findLCM(long a, long b) {
      return a * b / findGCD(a, b);
  }
  static long findGCD(long a, long b) {
      while(b != 0) {
          long tmp = b;
          b = a % b;
          a = tmp;
      }
      return a;
  }
}

```
## 🔹 필요한 개념 정리
### 창문과 정수론 문제 정리
#### 🔢 핵심 원리: 약수의 개수와 제곱수의 성질
1. **각 창문이 몇 번 바뀌는가?**
  - 창문이 열리고 닫히는 횟수는 **창문 번호의 약수 개수**와 같다.
  - 예를 들어, 창문 번호 `12`의 약수는 `{1, 2, 3, 4, 6, 12}` → **6개 (짝수 개수)** → `닫혀 있음`
  - 창문 번호 `9`의 약수는 `{1, 3, 9}` → **3개 (홀수 개수)** → `열려 있음`

2. **열린 창문의 규칙: 제곱수만 남는다!**
  - 숫자의 약수 개수는 대부분 짝수 개이므로 최종적으로 닫힌다.
  - 하지만, **제곱수(1, 4, 9, 16, …)** 는 **자기 자신을 곱한 수라서 약수 개수가 홀수**가 된다.
  - 예를 들어, `9`의 약수 `{1, 3, 9}`에서 `(3,3)`처럼 중복되는 약수가 존재하여 **약수 개수가 홀수**가 된다.

---

#### 📌 결론: 열린 창문의 개수
✅ **열린 창문의 개수 = 1 이상 N 이하의 제곱수 개수**  
즉,  
\[
\lfloor \sqrt{N} \rfloor
\]
이 값이 정답이 된다.

---

#### 🎯 예제
| N  | 열린 창문 개수 |
|----|--------------|
| 1  | 1 (1) |
| 5  | 2 (1, 4) |
| 10 | 3 (1, 4, 9) |
| 25 | 5 (1, 4, 9, 16, 25) |

---

#### 🏆 문제의 정수론적 의미
- 창문이 열리고 닫히는 과정은 **약수의 개수**와 관련이 있다.
- 약수 개수가 홀수인 수는 **제곱수뿐**이다.
- 따라서, **이 문제는 정수론(수학적 성질 분석)과 관련된 문제이다.**